---
title: 三、Golang之Go并发编程
date: 2021-03-27 22:49:57
tags: 
	- Golang高级
    - 并发编程
categories: 
    - Golang高级
    - 并发编程
---
# 一、概述:
所谓并发编程是指在一台处理器上“同时”处理多个任务;
宏观的并发是指在一段时间内, 有多个程序在同时运行;
并发在微观上, 是指在同一时刻只能有一条指令执行, 但多个程序指令被快速的轮换执行, 使得在宏观上具有多个进程同时执行的效果, 但在微观上并不是同时执行的, 只是把时间分成若干段, 使多个程序快速交替的执行;
![](/images/golang/006_并发.png)
## 1. 并行与并发:
并行(parallel): 指在同一时刻, 有多条指令在**多个处理器**上同时执行;
![](/images/golang/007_并发.png)
并发(concurrency)L指在同一时刻只能有一条指令执行, 但多个进程指令被快速的轮换执行, 使得在宏观上具有多个进程同时执行的效果, 但在微观上并不是同时执行的, 只是把时间分成若干段, 通过**cpu时间片轮转**使多个进程快速交替的执行;
![](/images/golang/008_并行.png)

- 并行是两个队列同时使用两台咖啡机 (真正的多任务)
- 并发是两个队列交替使用一台咖啡机 (假 的多任务)

![](/images/golang/009_ex_coffee.png)

# 二、常见并发编程技术:
## 1.进程并发
### 1.1 程序和进程:
- 程序:
    - 编译成功的得到的二进制文件;
    - 占用: 磁盘
- 进程:
    - 运行起来的程序;
    - 占用系统资源;(内存, 锁, cpu, ...)
    - 一个程序可以起多个线程;
### 1.2 进程状态:
进程基本的状态有5种; 分别为**初始态, 就绪态, 运行态, 挂起态与终止态**; 其中初始态为进程准备阶段; 常与就绪态结合来看;
![](/images/golang/010_线程状态.png)
    
### 1.2 进程并发
在使用进程 实现并发时可能会出现的问题呢: 
- 系统开销比较大, 占用资源比较多，开启进程数量比较少;
- 在unix/linux系统下, 还会产生"孤儿进程"和"僵尸进程";

通过前面查看操作系统的进程信息, 在操作系统中, 可以产生很多的进程; 在unix/linux系统中, 正常情况下, 子进程是通过父进程`fork`创建的, 子进程再创建新的进程;
并且父进程永远无法预测子进程 到底什么时候结束; 当一个 进程完成它的工作终止之后, 它的父进程需要调用系统调用取得子进程的终止状态;

**孤儿进程** :
- 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。
**僵尸进程** :
- 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  
Windows下的进程和Linux下的进程是不一样的，它比较懒惰，从来不执行任何东西，只是为线程提供执行环境。然后由线程负责执行包含在进程的地址空间中的代码。当创建一个进程的时候，操作系统会自动创建这个进程的第一个线程，成为主线程

## 2. 线程并发:
### 2.1 什么是线程:
LWP: light weight process 轻量级的进程, 本质仍是进程 (Linux下)
进程: 独立地址空间，拥有PCB 
线程: 有独立的PCB，但没有独立的地址空间(共享)
区别: 
    - 在于是否共享地址空间;
    - 线程: 最小的执行单位;
    - 进程: 最小分配资源单位, 可看成是只有一个线程的进程; 
Windows系统下, 可以直接忽略进程的概念, 只谈线程; 因为线程是最小的执行单位, 是被系统独立调度和分派的基本单位; 而进程只是给线程提供执行环境;
![](/images/golang/011_线程.png)

### 2.2 线程同步:
同步即协同步调, 按预定的先后次序运行; 
线程同步: 指一个线程发出某一功能调用时, 在没有得到结果之前, 该调用不返回; 同时其它线程为保证数据一致性, 不能调用该功能;

举例: 内存中100字节, 线程T1欲填入全1, 线程T2欲填入全0; 但如果T1执行了50个字节失去cpu, T2执行, 会将T1写过的内容覆盖; 当T1再次获得cpu继续从失去cpu的位置向后写入1, 当执行结束, 内存中的100字节, 既不是全1, 也不是全0;
产生的现象叫做**与时间有关的错误(time related)**; 为了避免这种数据混乱,线程需要同步;
“同步”的目的, 是为了避免数据混乱, 解决与时间有关的错误; 实际上, 不仅线程间需要同步, 进程间、信号间等等都需要同步机制;
因此, 所有“多个控制流, 共同操作一个共享资源”的情况, 都需要同步;

## 3. 锁的应用:
### 3.1 互斥量 mutex:
Linux中提供一把互斥锁mutex(也称之为互斥量);
每个线程在对资源操作前都尝试先加锁, 成功加锁才能操作, 操作结束解锁;
资源还是共享的, 线程间也还是竞争的, 但通过“锁”就将资源的访问变成互斥操作, 而后与时间有关的错误也不会再产生了;
![](/images/golang/012_mutex.png)

应注意: 同一时刻, 只能有一个线程持有该锁;
当A线程对某个全局变量加锁访问, B在访问前尝试加锁, 拿不到锁, B阻塞; C线程不去加锁, 而直接访问该全局变量, 依然能够访问, 但会出现数据混乱;
所以, 互斥锁实质上是操作系统提供的一把“建议锁”(又称“协同锁”), 建议程序中有多线程访问共享资源的时候使用该机制; 但, 并没有强制限定;
因此, 即使有了mutex, 如果有线程不按规则来访问数据, 依然会造成数据混乱;

### 3.2 读写锁
与互斥量类似, 但读写锁允许更高的并行性; 其特性为: 写独占, 读共享:

- 读写锁状态: 读写锁只有一把, 其具备两种状态:
    - 读模式下加锁状态 (读锁); 
    - 写模式下加锁状态 (写锁);

- 读写锁特性: 
    - 读写锁是“写模式加锁”时, 解锁前, 所有对该锁加锁的线程都会被阻塞; 
    - 读写锁是“读模式加锁”时, 如果线程以读模式对其加锁会成功; 如果线程以写模式加锁会阻塞; 
    - 读写锁是“读模式加锁”时, 既有试图以写模式加锁的线程, 也有试图以读模式加锁的线程; 那么读写锁会阻塞随后的读模式锁请求; 优先满足写模式锁; **读锁、写锁并行阻塞, 写锁优先级高**;

读写锁也叫共享-独占锁; 当读写锁以读模式锁住时, 它是以共享模式锁住的; 当它以写模式锁住时, 它是以独占模式锁住的; 写独占、读共享;
读写锁非常适合于对数据结构读的次数远大于写的情况;


## 4.协程并发:
### 4.1 什么是协程:
协程: coroutine, 也叫轻量级线程; 
与传统的系统级线程和进程相比, 协程最大的优势在于“轻量级”; 可以轻松创建上万个而不会导致系统资源衰竭; 而线程和进程通常很难超过1万个; 这也是协程别称“轻量级线程”的原因; 
一个线程中可以有任意多个协程, 但某一时刻只能有一个协程在运行, **多个协程分享该线程分配到的计算机资源**;
多数语言在语法层面并不直接支持协程,, 而是通过库的方式支持, 但用库的方式支持的功能也并不完整, 比如仅仅提供协程的创建、销毁与切换等能力; 如果在这样的轻量级线程中调用一个同步 IO 操作, 比如网络通信、本地文件读写, 都会阻塞其他的并发执行轻量级线程, 从而无法真正达到轻量级线程本身期望达到的目标;
在协程中, 调用一个任务就像调用一个函数一样, 消耗的系统资源最少! 但能达到进程、线程并发相同的效果; 
在一次并发任务中, 进程、线程、协程均可以实现; 从系统资源消耗的角度出发来看, 进程相当多, 线程次之, 协程最少;

### 4.2 Go并发
Go 在语言级别支持协程, 叫`goroutine`; Go 语言标准库提供的所有系统调用操作(包括所有同步IO操作), 都会出让CPU给其他`goroutine`; 这让轻量级线程的切换管理不依赖于系统的线程和进程, 也不需要依赖于CPU的核心数量;
有人把Go比作21世纪的C语言; 第一是因为Go语言设计简单, 第二21世纪最重要的就是并行程序设计, 而Go从语言层面就支持并行; 同时, 并发程序的内存管理有时候是非常复杂的, 而Go语言提供了自动垃圾回收机制;
Go语言为并发编程而内置的上层API基于**顺序通信进程模型CSP(communicating sequential processes)**; 这就意味着显式锁都是可以避免的, 因为Go通过相对安全的通道发送和接受数据以实现同步, 这大大地简化了并发程序的编写;
Go语言中的并发程序主要使用两种手段来实现; `goroutine`和`channel`;
## 5. Goroutine
### 5.1 什么是Goroutine
`goroutine`是Go并行设计的核心; `goroutine`说到底其实就是协程, 它比线程更小, 十几个goroutine可能体现在底层就是五六个线程, Go语言内部实现了这些goroutine之间的内存共享; 执行goroutine只需极少的栈内存(大概是4~5KB), 当然会根据相应的数据伸缩; 也正因为如此, 可同时运行成千上万个并发任务; goroutine比thread更易用、更高效、更轻便; 
一般情况下, 一个普通计算机跑几十个线程就有点负载过大了, 但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争;

### 5.2 Goroutine的创建
只需在函数调⽤语句前添加 `go` 关键字, 就可创建并发执⾏单元; 开发⼈员无需了解任何执⾏细节, 调度器会自动将其安排到合适的系统线程上执行; 
在并发编程中, 通常想将一个过程切分成几块, 然后让每个goroutine各自负责一块工作, 当一个程序启动时, 主函数在一个单独的goroutine中运行, 叫`main goroutine`; 新的goroutine会用go语句来创建; 而go语言的并发设计, 很轻松就可以达成这一目的;
```go
package main

import (
    "fmt"
    "time"
)

func newTask() {
    i := 0
    for {
        i++
        fmt.Printf("new goroutine: i = %d\n", i)
        time.Sleep(1 * time.Second) //延时1s
    }
}

func main() {
    //创建一个 goroutine，启动另外一个任务
    go newTask()
    i := 0
    //main goroutine 循环打印
    for {
        i++
        fmt.Printf("main goroutine: i = %d\n", i)
        time.Sleep(1 * time.Second) //延时1s
    }
}
```
![](/images/golang/013_goroutine.png)

### 5.3 Goroutine特性:
主goroutine退出后，其它的工作goroutine也会自动退出;

## 6. runtime包:
### 6.1 Gosched
`runtime.Gosched()` 用于让出CPU时间片, 让出当前goroutine的执行权限, 调度器安排其他等待的任务运行, 并在下次再获得cpu时间轮片的时候, 从该出让cpu的位置恢复执行;
```go
package main

import (
"fmt"
"runtime"
)

func main() {
    //创建一个goroutine
    go func(s string) {
        for i := 0; i < 2; i++ {
            fmt.Println(s)
        }
    }("world")

    for i := 0; i < 2; i++ {
        runtime.Gosched()  //import "runtime" 包
        /*
            屏蔽runtime.Gosched()运行结果如下：
                hello
                hello

            有runtime.Gosched()运行结果如下：
                world
                world
                hello
                hello
        */
        fmt.Println("hello")
    }
}
```
主协程进入`main()`函数, 进行代码的执行; 当执行到`go func()`匿名函数时, 创建一个新的协程, 开始执行匿名函数中的代码, 主协程继续向下执行, 执行到`runtime.Gosched()`时会暂停向下执行, 直到其它协程执行完后, 再回到该位置, 主协程继续向下执行;

### 6.2 Goexit 
调用 `runtime.Goexit()` 将立即终止当前 `goroutine` 执⾏, 调度器确保所有已注册 `defer`延迟调用被执行;
```go
package main

import (
"fmt"
"runtime"
)

func main() {
    go func() {
        defer fmt.Println("A.defer")

        func() {
            defer fmt.Println("B.defer")
            runtime.Goexit() // 终止当前 goroutine, import "runtime"
            fmt.Println("B") // 不会执行
        }()

        fmt.Println("A") // 不会执行
    }() 	//不要忘记()

    //死循环，目的不让主goroutine结束
    for {
    }
}
```
结果:
```
B.defer
A.defer
```

### 6.3 GOMAXPROCS
调用 `runtime.GOMAXPROCS()` 用来设置可以并行计算的CPU核数的最大值, 并返回之前的值
```go
package main

import (
    "fmt"
)

func main() {
//n := runtime.GOMAXPROCS(1) 	// 第一次 测试
//打印结果：111111111111111111110000000000000000000011111...

n := runtime.GOMAXPROCS(2)         // 第二次 测试
//打印结果：010101010101010101011001100101011010010100110...
    fmt.Printf("n = %d\n", n)

    for {
        go fmt.Print(0)
        fmt.Print(1)
    }
}
```
在第一次执行`runtime.GOMAXPROCS(1)` 时, 最多同时只能有一个goroutine被执行, 所以会打印很多1; 过了一段时间后, GO调度器会将其置为休眠, 并唤醒另一个goroutine, 这时候就开始打印很多0了, 在打印的时候, goroutine是被调度到操作系统线程上的;
在第二次执行`runtime.GOMAXPROCS(2)` 时, 使用了两个CPU, 所以两个goroutine可以一起被执行, 以同样的频率交替打印0和1;

### 6.4 其他方法:
https://studygolang.com/pkgdoc


## 7. channel 管道:
### 7.1 什么是channel:
channel是Go语言中的一个**核心类型**, 可以把它看成管道; 并发核心单元通过它就可以发送或者接收数据进行通讯, 这在一定程度上又进一步降低了编程的难度; 
channel是一个数据类型, 主要用来解决协程的同步问题以及协程之间数据共享(数据传递)的问题;
goroutine运行在相同的地址空间, 因此访问共享内存必须做好同步; **goroutine 奉行通过通信来共享内存, 而不是共享内存来通信**;
引⽤类型 channel可用于多个 goroutine 通讯; 其内部实现了**同步, 确保并发安全**;
![](/images/golang/014_channel通讯.png)

### 7.2 定义channel变量:
和map类似, channel也一个对应`make`创建的底层数据结构的引用;
当复制一个channel或用于函数参数传递时, 只是拷贝了一个channel引用, 因此调用者和被调用者将引用同一个channel对象; 和其它的引用类型一样, channel的零值也是nil; 
定义一个channel时, 也需要定义发送到channel的值的类型; channel可以使用内置的`make()`函数来创建:
    - `chan`是创建channel所需使用的关键字;
    - `Type` 代表指定channel收发数据的类型;

```go
make(chan Type)  // 等价于make(chan Type, 0) => 无缓冲,只能容纳一个变量
make(chan Type, capacity) // => 有缓冲通道
```
当 `capacity = 0` 时, channel 是无缓冲阻塞读写的;
当 `capacity > 0` 时, channel 有缓冲、是非阻塞的, 直到写满 capacity个元素才阻塞写入;

channel一边可以存放东西, 另一边可以取出东西; channel通过操作符 `<-` 来接收和发送数据;
发送和接收数据语法:
```go
channel <- value      //发送value到channel

<-channel             //接收并将其丢弃
x := <-channel        //从channel中接收数据，并赋值给x
x, ok := <-channel    //功能同上，同时检查通道是否已关闭或者是否为空
```
默认情况下, channel接收和发送数据都是阻塞的, 除非另一端已经准备好, 这样就使得goroutine同步变的更加的简单, 而不需要显式的lock;
```go
package main

import (
    "fmt"
)

func main() {
    c := make(chan int)

    go func() {
        defer fmt.Println("子协程结束")

        fmt.Println("子协程正在运行……")

        c <- 666 //666发送到c
    }()

    num := <-c //从c中接收数据，并赋值给num

    fmt.Println("num = ", num)
    fmt.Println("main协程结束")
}
```
结果:
```
子协程正在运行......
子协程结束
num = 666
main协程结束
```




